import app from"/js/site.min.js";const d=app.d,df=d.domfn,{div:div,button:button,h4:h4,section:section,span:span,header:header}=df,{toggleBox:toggleBox}=app.components;app.fetchComments=async(t,e={})=>{null==e.path&&(e.path=t+"/"),null==e.page&&(e.page=1);try{const t=await app.jsonPost("/comments",e);return await t.json()}catch(t){return{ok:!1}}},app.makeComment=async(t,e,n=app.gatherComment())=>{if(null==n.public&&(n.public=!0),null==n.author_only&&(n.author_only=!1),null==t||t.length<2)throw new Error("app.makeComment: invalid parent id");if(null==e&&(e=t),e.length<2)throw new Error("app.makeComment: invalid writ id");if(null==n.raw_content||n.raw_content.length<2)throw new Error("app.makeComment: invalid comment content, it's either too long or too short");const o=await app.jsonPut("/comment",{parent_id:t,writ_id:e,public:n.public,raw_content:n.raw_content,author_only:n.author_only});return await o.json()};const commentsDisplay=app.commentsDisplay=section({$:app.postDisplay,class:"comments"},t=>[header(h4("Comments")),t.commentWriter=div({class:"comment-writer"},t.textarea=df.textarea({placeholder:"write a comment"}),div({class:"comment-controls"},div({class:"togglebox-container"},df.label({attr:{for:"author-only"}},"Author Only"),t.authorOnlyToggle=toggleBox("author-only",{id:"author-only",attr:{title:"check this to make your comment visible only to the post author and no one else"}})),t.cancelBtn=button({class:"cancel-btn",onclick(e){t.textarea.value="",t.authorOnlyToggle.input.checked&&(t.authorOnlyToggle.input.checked=!1),app.editingComment=null}},"Cancel"),t.postBtn=button({class:"post-btn"},"Post"))),t.list=div({class:"comment-list"})]);app.gatherComment=()=>{const{textarea:t,authorOnlyToggle:e}=commentsDisplay;return{raw_content:t.value.trim(),author_only:e.input.checked}};const commentPostHandler=d.once.click(commentsDisplay.postBtn,async t=>{try{let t;if(commentsDisplay.classList.contains("edit-mode"))app.editingComment.raw_content=commentsDisplay.textarea.value,app.editingComment.author_only=commentsDisplay.authorOnlyToggle.input.checked,t=await app.confirmCommentEdit(app.editingComment);else if(t=await app.makeComment(app.activePostDisplay.id),!t.ok)throw t.status||"very bad, comment post failed miserably";commentsDisplay.list.prepend(app.formulateThread(t.data))}catch(t){console.error(t)}finally{commentsDisplay.textarea.value="",commentsDisplay.authorOnlyToggle.input.checked&&(commentsDisplay.authorOnlyToggle.input.checked=!1),commentsDisplay.postBtn.textContent="Post",commentPostHandler.on()}});app.commentDateFormat=t=>"  "+dayjs.unix(t).utcOffset(2).fromNow(),app.deleteComment=async t=>{t=t.replace("-","/");const e=await d.queryAsync(`[id="comment-${t}"]`);e.querySelector("span.delete").classList.add("idle-animation");const n=await(await app.jsonDelete("/comment",t)).json();console.log(n),n.ok&&(df.remove(e),app.toast.msg("Comment succesfully deleted"))},app.editComment=async t=>{const e=await d.queryAsync(`[id="comment-${t.replace("-","/")}"]`),n=await(await fetch(`/comment/${t}/raw-content`)).json();if(!n.ok)throw new Error("Could not retrieve comment raw_content");commentsDisplay.textarea.value=n.data,commentsDisplay.postBtn.textContent="Confirm Edit",commentsDisplay.classList.add("edit-mode"),app.editingComment={id:t,writ_id:app.activePostDisplay.id},e.setAttribute("hidden",""),e.style.position="fixed",app.editingCommentElement=e},app.confirmCommentEdit=async t=>{if(null==t)throw new Error("Cannot edit a non-existent comment");const e=await(await app.jsonPost("/edit-comment",t)).json();if(!e.ok)throw app.toast.error("Failed to edit comment: "+e.status),app.editingCommentElement&&(app.editingCommentElement.removeAttribute("hidden"),app.editingCommentElement.style.position="",app.editingCommentElement=null),new Error("app.confirmCommentEdit: "+e.status||"it didn't work :(");return app.toast.msg("Comment successfully edited"),app.editingCommentElement=null,e},app.on.postRendered(async t=>{if(app.activePostDisplay=t,app.postDisplay.classList.toggle("with-comments",t.commentable),!t.commentable)return void df.remove(commentsDisplay);commentsDisplay.list.innerHTML="",d.render(commentsDisplay,app.postDisplay);const e=await app.fetchComments(t.id);if(!e.ok)return;const n=e.data,o=[];for(const{comment:t,children:e}of n)o.push(app.formulateThread(t,e));d.render(o,commentsDisplay.list)}),app.formulateThread=(t,e)=>div({class:"comment",attr:{id:"comment-"+t.id}},header(app.votesUI("comment",(t.id=t.id.replace("/","-"),t)),span({class:"author-name"},t.author_name),span({class:"txt-divider"}," - "),span({class:"posted"},app.renderUXTimestamp(t.posted,app.commentDateFormat)),span({class:"divider"}),span({class:"delete",attr:{title:"click to delete your comment"},onclick(e){app.deleteComment(t.id)}},app.dismissIcon())),div({class:"content"},d.html(t.content)),div({class:"btn-rack"},null!=app.user.username&&t.author_name==app.user.username&&button({class:"edit-btn",onclick(){app.editComment(t.id)}},"edit")),null==e||e.length>0&&div({class:"children"},e.map(t=>app.formulateThread(t.comment,t.children))));
//# sourceMappingURL=comments.min.js.map